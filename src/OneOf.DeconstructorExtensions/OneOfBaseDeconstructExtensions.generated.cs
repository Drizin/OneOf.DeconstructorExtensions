using System;
namespace OneOf
{
    #nullable enable
    /// <summary>
    /// Extensions that deconstruct the OneOfBase.
    /// Only one of the returned elements will have a non-null value.
    /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types
    /// </summary>
    public static class OneOfBaseDeconstructExtensions
    {
        /// <summary>
        /// Constraints are not part of the signature, but parameters are.
        /// Constraints in parameters are enforced during overload resolution, so we put the constraints in optional disambiguation parameters.
        /// </summary>
        public class RequireStruct<T> where T : struct { }

        /// <summary>
        /// Constraints are not part of the signature, but parameters are.
        /// Constraints in parameters are enforced during overload resolution, so we put the constraints in optional disambiguation parameters.
        /// </summary>
        public class RequireClass<T> where T : class { }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1>(this OneOfBase<T0, T1> oneOf, out T0? item0, out T1? item1)
            where T0 : class
            where T1 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1>(this OneOfBase<T0, T1> oneOf, out T0? item0, out Nullable<T1> item1)
            where T0 : class
            where T1 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1>(this OneOfBase<T0, T1> oneOf, out Nullable<T0> item0, out T1? item1)
            where T0 : struct
            where T1 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1>(this OneOfBase<T0, T1> oneOf, out Nullable<T0> item0, out Nullable<T1> item1)
            where T0 : struct
            where T1 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2>(this OneOfBase<T0, T1, T2> oneOf, out T0? item0, out T1? item1, out T2? item2)
            where T0 : class
            where T1 : class
            where T2 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2>(this OneOfBase<T0, T1, T2> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2)
            where T0 : class
            where T1 : class
            where T2 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2>(this OneOfBase<T0, T1, T2> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2)
            where T0 : class
            where T1 : struct
            where T2 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2>(this OneOfBase<T0, T1, T2> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2)
            where T0 : class
            where T1 : struct
            where T2 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2>(this OneOfBase<T0, T1, T2> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2)
            where T0 : struct
            where T1 : class
            where T2 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2>(this OneOfBase<T0, T1, T2> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2)
            where T0 : struct
            where T1 : class
            where T2 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2>(this OneOfBase<T0, T1, T2> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2)
            where T0 : struct
            where T1 : struct
            where T2 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2>(this OneOfBase<T0, T1, T2> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2)
            where T0 : struct
            where T1 : struct
            where T2 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3>(this OneOfBase<T0, T1, T2, T3> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3>(this OneOfBase<T0, T1, T2, T3> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3>(this OneOfBase<T0, T1, T2, T3> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3>(this OneOfBase<T0, T1, T2, T3> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3>(this OneOfBase<T0, T1, T2, T3> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3>(this OneOfBase<T0, T1, T2, T3> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3>(this OneOfBase<T0, T1, T2, T3> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3>(this OneOfBase<T0, T1, T2, T3> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3>(this OneOfBase<T0, T1, T2, T3> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3>(this OneOfBase<T0, T1, T2, T3> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3>(this OneOfBase<T0, T1, T2, T3> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3>(this OneOfBase<T0, T1, T2, T3> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3>(this OneOfBase<T0, T1, T2, T3> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3>(this OneOfBase<T0, T1, T2, T3> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3>(this OneOfBase<T0, T1, T2, T3> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3>(this OneOfBase<T0, T1, T2, T3> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4>(this OneOfBase<T0, T1, T2, T3, T4> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5>(this OneOfBase<T0, T1, T2, T3, T4, T5> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out T0? item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : class
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (T0?)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out T1? item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : class
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (T1?)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out T2? item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : class
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (T2?)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out T3? item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : class
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (T3?)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out T4? item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : class
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (T4?)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out T5? item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : class
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (T5?)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out T6? item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : class
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (T6?)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out T7? item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : class
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (T7?)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out T8? item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : class
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (T8?)oneOf.AsT8 : null);
        }

        /// <summary>
        /// Deconstructs the OneOfBase.
        /// Only one element of the Tuple will have a non-null value.
        /// All generic types of OneOfBase should either be non-nullable value types or non-nullable reference types.
        /// All optional parameters named "dummy" will be ignored - they are just used for compiler disambiguation (to find the right combination of reference-types and value-types)
        /// </summary>
        public static void Deconstruct<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this OneOfBase<T0, T1, T2, T3, T4, T5, T6, T7, T8> oneOf, out Nullable<T0> item0, out Nullable<T1> item1, out Nullable<T2> item2, out Nullable<T3> item3, out Nullable<T4> item4, out Nullable<T5> item5, out Nullable<T6> item6, out Nullable<T7> item7, out Nullable<T8> item8)
            where T0 : struct
            where T1 : struct
            where T2 : struct
            where T3 : struct
            where T4 : struct
            where T5 : struct
            where T6 : struct
            where T7 : struct
            where T8 : struct
        {
            item0 = (oneOf.Index == 0 ? (Nullable<T0>)oneOf.AsT0 : null);
            item1 = (oneOf.Index == 1 ? (Nullable<T1>)oneOf.AsT1 : null);
            item2 = (oneOf.Index == 2 ? (Nullable<T2>)oneOf.AsT2 : null);
            item3 = (oneOf.Index == 3 ? (Nullable<T3>)oneOf.AsT3 : null);
            item4 = (oneOf.Index == 4 ? (Nullable<T4>)oneOf.AsT4 : null);
            item5 = (oneOf.Index == 5 ? (Nullable<T5>)oneOf.AsT5 : null);
            item6 = (oneOf.Index == 6 ? (Nullable<T6>)oneOf.AsT6 : null);
            item7 = (oneOf.Index == 7 ? (Nullable<T7>)oneOf.AsT7 : null);
            item8 = (oneOf.Index == 8 ? (Nullable<T8>)oneOf.AsT8 : null);
        }

    }
    #nullable disable
}
